# 8.1 排序的定义

# 8.2 插入排序

插入排序是一种简单直观的排序方法，其基本思想是**每次将一个待排序的记录按照其关键字的大小插入到前面已排好序的子序列**，直到全部记录插入完成。由插入排序的思想可以引申出三个
重要的排序算法:直接插入排序、折半插入排序和希尔排序。

## 8.2.1 直接插入排序

​	最简单的插入排序算法。

```java
public void InsertSort(int[] nums){
	for(int i = 1; i < nums.length; i++){//依次将nums[1]~nums[nums.length-1]插入前面已排序序列
        if(nums[i].compareTo(nums[i - 1]){//若nums[i]关键字小于前驱
            int temp = nums[i];//用temp暂存nums[i]
            for(int j = i - 1; j >= 0 && nums[j] > temp; --j)//检查所有前面已排好序的元素
                nums[j + 1] = nums[j];//大于temp(nums[i])的元素后移
            nums[j + 1] = temp;//在j=-1时将j右边的值赋值为temp复制到插入位置
        }
	}
}
```

直接插入排序算法性能分析：

​	空间效率：仅使用了常数个辅助单元，空间复杂度为O(1)

​	时间效率：在排序过程中，向有序子表中逐个地插入元素的操作进行了 n - 1 趟，每次操作都分为 比较关键字和移动元素，而比较次数和移动次数取决于待排序表的初始状态。

​		最好的情况下，表中元素有序，此时每插入一个元素，都只需比较一次而不用移动元素，
$$
因而时间复杂度为O(n)
$$
​		最坏的情况下，表中元素逆序，此时比较次数与移动次数都达到最大，
$$
因而时间复杂度为O(n^2)
$$

$$
平均情况下，考虑待排序表中元素是随机的，此时可以取上述最好与最坏情况的\\
平均值作为平均情况下的  时间复杂度，总的比较次数与总的移动次数均约\\
为n^2/4。所以，直接插入排序的时间复杂度为O(n^2)
$$



稳定性：由于每次插入元素时总是从后向前先比较再移动，所以不会出现相同元素相同位置发生变化的情况，即直接插入排序时一个**稳定的**排序算法。

适用性：直接插入排序算法适用于顺序存储和链式存储的线性表。为链式存储时，可以从前往后直找指定元素的位置。

## 8.2.2 折半插入排序

​	从直接插入排序算法中，不难看出每趟插入的过程中都进行了两项工作:①从前面的有序子表中查找出待插入元素应该被插入的位置:②给插入位置腾出空间，将待插入元素复制到表中的插入位置。注意到在该算法中，总是边比较边移动元素。下面将比较和移动操作分离，即先折半查找出元素的待插入位置，然后统-地移动待插入位置之后的所有元素。 当排序表为顺序表时，可以对直接插入排序算法做如下改进:由于是顺序存储的线性表，所以查找有序子表时可以用折半查找来实现。确定待插入位置后，就可统- -地向后移动元素。 算法代码如下:

```java
public void InsertSort(int[] nums){
	for(int i = 2; i <= nums.length ; i++){//
        
        依次将nums[2]~nums[nums.length - 1]插入到前面的已排序序列
        int temp = nums[i];
        int left = 0 , right = i - 1;
        while(left <= right){ //折半查找
            int mid = (left + right) / 2;
            if(nums[mid] > temp) right = mid - 1;
            else  left = mid + 1;
        }
        for(int j = i - 1 ; j > right + 1 ; j--)
            nums[j + 1] = nums[j];
        nums[rright + 1] = temp;
    }
}
```
​	从上述算法中，不难看出**折半插入排序仅减少了比较元素的次数，约为O(nlogm)**,该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数n;而元素的移动次数并未改变，它依赖于待排序表的初始状态。**因此,折半插入排序的时间复杂度仍为0(n^2)**，但对于数据量不很大的排序表，折半插入排序往往能表现出很好的性能。折半插入排序是一-种稳定的排序方法。

# 8.2.3 希尔排序

​	从前面的分析可知，**直接插入排序**算法的时间复杂度为0(n^2)，但若待排序列为“正序”时，其时间复杂度可提高至O(n)，由此可见它更**适用于基本有序的排序表和数据量不大的排序表**。希尔排序正是基于这两点分析对直接插入排序进行改进而得来的，又称**缩小增量排序**。
​	希尔排序的基本思想是：先将待排序表分割成若干形如 L[i,i+d,i+ 2.,.. i+ kd] 的“特殊”子表，即把相隔某个“增量”的记录组成一个子表，对各个子表分别进行直接插入排序，当整个表中的元素已呈“基本有序”时，再对全体记录进行一次直接插入排序。缩小增量d，重复上述过程，知道d=1为止。
$$
对于增量d，常用的方法是d_1 = n/2，d_{i+1} = d_i / 2(向下取整)，并且最后一个增量等于1。
$$

```java
public void ShellSort(int[] nums){
    for(int d = numd.length / 2 ; d > 0 ; d = d / 2){
        for(int i = d ; i < nums.length ; i++){ //i指向第一个子表中的第二个元素
            if(nums[i].compareTo(nums[i - d]) < 0){
                int temp = nums[i];
                for(int j = i - d ; j >= 0 && nums[j].compareTo(temp) > 0 ; j = j - d)
                    nums[j + d] = nums[j];//记录后移，查找插入的位置
                nums[j + d] = temp; //nums[j+d]此时为子表第一个元素
            }
        }
    }  
}
```

​	希尔排序算法的性能分析如下: 
​		空间效率:仅使用了常数个辅助单元，因而空间复杂度为0(1)。
​		时间效率:由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。
$$
当n在某个特定范围时，希尔排序的时间复杂度约为0(n^{1.3})。在最坏情况下希尔排序的时间复杂度为0(n^2)。
$$
​		稳定性:当相同关键字的记录被划分到不同的子表时，可能会改变它们之间的相对次序，因此希尔排序是一种**不稳定**的排序方法。
​		适用性:希尔排序算法**仅适用于线性表为顺序存储**的情况。

# 8.3 交换排序

​	交换，是指根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置。

## 8.3.1 冒泡排序

​	冒泡排序的基本思想是：从后往前(或从前往后)两两比较相邻元素的值，若为逆序(即A[i-1]>A[i])，则交换它们，直到序列比较完。第一趟冒泡，结果是将最小的元素交换到待排序列的第一个位置(或将最大的元素交换到待排序列的最后一个位置)，关键字最小的元素如气泡一般逐渐往上“漂浮”直至“水面”(或关键字最大的元素如石头一般下沉至水底)。下一趟冒泡时,前一趟确定的最小元素不再参与较，每趟冒泡的结果是把序列中的最小元素(或最大元素)放到了序列的最终位....这样最多做n- 1趟冒泡就能把所有元素排好序。

```java
public void BubbleSort(int nums[] nums){
    for(int i = 1 ; i < nums.length ; i++){
        bollean flag = flase;
        for(int j = 0 ; j < nums.length - i ; j++){
            if(nums[j] > nums[j+1]){
                swap(nums, j, j+1);
                flag = true;
            }
        }
        if(flag == flase)
            return;
    }  
}
```

​	冒泡排序的性能分析如下:
​		空间效率:仅使用了常数个辅助单元，因而**空间复杂度为0(1)**。
​		时间效率:当初始序列有序时，显然第一趟冒泡后flag依然为false (本趟冒泡没有元素交换)，从而直接跳出循环，比较次数为n- 1，移动次数为0，从而**最好情况下的时间复杂度为O(n)**；当初始序列为逆序时，需要进行n- 1趟排序，第i趟排序要进行n -i次关键字的比较，而且每次比较后都必须移动元素3次来交换元素位置。这种情况下，

![image-20220911120524865](C:\Users\24193\AppData\Roaming\Typora\typora-user-images\image-20220911120524865.png)
$$
从而，最坏情况下的时间复杂度为0(n^2),其平均时间复杂度也为0(n^2)。
$$
​		稳定性:由于 i > j 且 A[i] = A[j] 时，不会发生交换，因此冒泡排序是一种稳定的排序方法。

## 8.3.2 快速排序

​	快速排序的基本思想是基于分治法的:在待排序表 L[1..n] 中任取一-个元素 pivot 作为枢轴(或基准,通常取首元素)，通过一趟排序将待排序表划分为独立的两部分 L[l..k-1] 和 L [k+1...n]，使得 L[1..k-1] 中的所有元素小于pivot,，L[k+1..n]中的所有元素大于等于pivot,则pivot放在了其最终位置L(k)上,这个过程称为一趟快速排序(或一次划分)。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上。

```java
public void QuickSort(int[] nums , int left ,int right){
		if (left < right) {
            int partitionIndex = partition(arr, left, right);
            quickSort(arr, left, partitionIndex - 1);
            quickSort(arr, partitionIndex + 1, right);
        }
        return arr;
}

private int partition(int[] arr, int left, int right) {
        // 设定基准值（pivot）
        int pivot = left;
        int index = pivot + 1;
        for (int i = index; i <= right; i++) {
            if (arr[i] < arr[pivot]) {
                swap(arr, i, index);
                index++;
            }
        }
        swap(arr, pivot, index - 1);
        return index - 1;
    }

private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

```

​	快速排序算法的性能分析如下:
​		空间效率:由于快速排序是递归的，需要借助-一个递归工作栈来保存每层递归调用的必要信息，其容量应与递归调用的最大深度一致。 
$$
最好情况下为O(logz_2n);最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n);\\
平均情况下，栈的深度为0(log_2n)。
$$
​		时间效率:快速排序的运行时间与划分是否对称有关，快速排序的最坏情况发生在两个区域分别包含n-1个元素和0个元素时，这种最大程度的不对称性若发生在每层递归上，即对应于初始排序表基本有序或基本逆序时，就得到**最坏情况下的时间复杂度为0(n)**。
​	有很多方法可以提高算法的效率：一种方法是尽量选取一个可以将数据中分的枢轴元素，如从序列的头尾及中间选取三个元素，再取这三个元素的中间值作为最终的枢轴元素；或者随机地从当前表中选取枢轴元素，这样做可使得最坏情况在实际排序中几乎不会发生。
​	在最理想的状态下，即Partition 可能做到最平衡的划分，得到的两个子问题的大小都不可能大于n/2，在这种情况下，快速排序的运行速度将大大提升，
$$
此时，时间复杂度为O(nlog_2n)。
$$
好在**快速排序平均情况下的运行时间与其最佳情况下的运行时间很接近，**而不是接近其最坏情况下的运行时间。**快速排序是所有内部排序算法中平均性能最优的排序算法**。
		稳定性:在划分算法中，若右端区间有两个关键字相同，且均小于基准值的记录，则在交换到左端区间后，它们的相对位置会发生变化，即**快速排序是一种不稳定**的排序方法。例如，表L={3,2,2}，经过一趟排序后L= {2,2,3},最终排序序列也是L= {2,2,3}，显然，2与2的相对次序已发生了变化。

# 8.4 选择排序

​	选择排序的基本思想是：每一趟(如第i趟)在后面 n-i+1 (i=1,2,-*,n-1) 个待排序元素中选取关键字最小的元素，作为有序子序列的第 i 个元素，直到第 n-1 趟做完，待排序元素只剩下1个，就不用再选了。

## 8.4.1 简单选择排序

​	假设排序表为L[1..n]，第i趟排序即从L[i...n]中选择关键字最小的元素与L(i)交换，每一趟排序可以确定一个元素的最终位置，这样经过 n- 1趟排序就可使得整个排序表有序。

```java
public void SelectSort(int[] nums){
    for(int i = 0 ;i < nums.length - 1 ; i++){
        int min = i;
        for(int j = i + 1; j < nums.length ;j++)
            if(nums[j] < nums[min]) min = j;
        if(min != i) swap(nums[i], nums[min]);
    }
}
```

​	简单选择排序算法的性能分析如下:
​		空间效率:仅使用常数个辅助单元，故空间效率为0(1)。
​		时间效率：在简单选择排序过程中，元素移动的操作次数很少，不会超过3(n- 1)次，最好的情况是移动0次，此时对应的表已经有序:但元素间比较的次数与序列的初始状态无关，始终是n(n- 1)/2次，因此时间复杂度始终是O(n)。
​		稳定性：在第i趟找到最小元素后，和第i个元素交换，可能会导致第i个元素与其含有相同关键字元素的相对位置发生改变。例如，表L= {2,2,1}，经过一-趟排序后L= {1,2,2}，最终排序序列也是L-={1,2,2}，显然，2与2的相对次序已发生变化。因此，**简单选择排序是一种不稳定的排序方法。**

## 8.4.2 堆排序

​	堆的定义如下，n个关键字序列L[1...n]称为堆，当且仅当该序列满足:
​		①L(i)>=L(2i)且L(i)>=L(2i+1) 或
​		②L(i)<=L(2i)且L(i)<=L(2i+1) (1≤i<=n/2(向下取整))
​	可以将该一维数组视为一棵完全二叉树，满足条件①的堆称为大根堆(大顶堆),大根堆的最大元素存放在根结点，且其任一非根结点的值小于等于其双亲结点值。满足条件②的堆称为小根堆(小顶堆),小根堆的定义刚好相反，根结点是最小元素。

​	堆排序的思路很简单:首先将存放在L[1...n]中的n个元素建成初始堆，由于堆本身的特点(以大顶堆为例)，堆顶元素就是最大值。输出堆顶元素后，通常将堆底元素送入堆顶，此时根结点已不满足大顶堆的性质，堆被破坏，将堆顶元素向下调整使其继续保持大顶堆的性质，再输出堆顶元素。如此重复，直到堆中仅剩一个元素为止。可见堆排序需要解决两个问题:①如何将无序序列构造成初始堆?②输出堆顶元素后，如何将剩氽元素调整成新的堆?

​	堆排序的关键是构造初始堆。n个结点的完全二叉树，最后一个结点是第L[n/2」个结点的孩子。对第L[n/2J个结点为根的子树筛选(对于大根堆，若根结点的关键字小于左右孩子中关键字较大者，则交换)，使该子树成为堆。之后向前依次对各结点(L[n/2J-1~1)为根的子树进行筛选，看该结点值是否大于其左右子结点的值，若不大于，则将左右子结点中的较大值与之交换，交换后可能会破坏下一级的堆， 于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆为止。反复利用上述调整堆的方法建堆，直到根结点。

```java
public void HeapSort(int[] nums){
    	int len = nums.length;
        buildMaxHeap(nums, len);
        for (int i = len - 1; i > 0; i--) {
            swap(nums, 0, i);
            len--;
            heapify(nums, 0, len);
        } 
}
private void buildMaxHeap(int[] nums, int len) {
        for (int i = (int) Math.floor(len / 2); i >= 0; i--) {
            heapify(nums, i, len);
        }
    }

private void heapify(int[] nums, int i, int len) {
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        int largest = i;

        if (left < len && nums[left] > nums[largest]) {
            largest = left;
        }

        if (right < len && nums[right] > nums[largest]) {
            largest = right;
        }

        if (largest != i) {
            swap(nums, i, largest);
            heapify(nums, largest, len);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

​	堆排序算法的性能分析如下:
​		空间效率:仅使用了常数个辅助单元，所以空间复杂度为0(1)。
​		时间效率:建堆时间为0(n),之后有 n-1次向下调整操作，每次调整的时间复杂度为O(n)，
$$
故在最好、最坏和平均情况下，堆排序的时间复杂度为O(nlog_2n)。
$$
​		稳定性:进行筛选时，有可能把后面相同关键字的元素调整到前面，所以**堆排序算法是一种不稳定的排序方法**。
